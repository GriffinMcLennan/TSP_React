Algorithms will solve solve the problem and return a list of all the solutions and then the best solution.

Animate will iterate over the list and animate it.

Canvas class holds information about where circles are.

Pass canvas reference to algorithms,


canvas {
    canvas_Ref;
}

Algorithms(canvas, circles, parent function to state distances) {
    solve algorithm to get list of nodes & list of distances.

    animate(canvas, list)
}

Animate(canvas, list) {
    animate list
}

How do react state updates work? Wondering about how to update score etc.
Change bestDistance to -1 placeholder value. Distance can't be negative.
Look up arrow functions binding react: Arrow functions do not bind to their own this, they inherit it from their parent.

Algorithms return a list of the states and a list of the distances.

Canvas {
    canvas;
    state = {
        distance,
        bestDistance,
        circles,
        bestPath,
    }

    setBestPath(path, bestDistance)

    addCircle() {
        circlesCopy = this.state.circles.slice();
        circlesCopy.push([x, y]);
        this.setState({circles : circlesCopy});
        drawCircle(canvas, x, y);
    }

    SimulatedAnnealingAlg() {
        paths, distances = SimulatedAnnealing(this.state.circles)

        animatePaths(paths, distances, setBestPath)
    }

}

Include animations in separate class as it demonstrates knowledge of passing functions and more separated clean code.

animations folder:
    animatePath(paths, distances, setBestPath)

    drawCircle(canvas, x, y, init=false)

    clearCanvas(canvas)

Algorithms folder:
    RandomSwap
    SimulatedAnnealing
    calculateDistance



???
- Initial population of 100(? maybe change) paths,
- track best solution for each iteration.