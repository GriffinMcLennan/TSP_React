{"version":3,"sources":["Animations/drawCircle.js","Animations/clearCanvas.js","Animations/drawTSP.js","Animations/animateBestPath.js","Algorithms/findMinMax.js","Algorithms/scaleList.js","Animations/animatePath.js","Algorithms/copyList.js","Algorithms/calcDistance.js","Algorithms/swap.js","Algorithms/random.js","Algorithms/acceptanceProbability.js","Algorithms/simulatedAnnealing.js","Algorithms/Genetic_Algorithm/shuffle.js","Algorithms/Genetic_Algorithm/Path.js","Algorithms/Genetic_Algorithm/Population.js","Algorithms/Genetic_Algorithm/pickOne.js","Algorithms/Genetic_Algorithm/GA.js","Modal.js","App.js","index.js"],"names":["drawCircle","canvasRef","x","y","ctx","getContext","strokeStyle","beginPath","arc","Math","PI","fillStyle","fill","stroke","clearCanvas","canvas","clearRect","width","height","drawTSP","path","arr","i","length","moveTo","lineTo","animateBestPath","doneDrawing","deltaTime","setTimeout","findMinMax","list","min","max","scaleList","canvasHeight","scaleFactor","console","log","scaledList","push","animatePath","canvas2Ref","paths","distances","updateDistances","currentDistance","bestDistance","ctx2","invalidGraph","minDist","maxDist","scaledValues","delX","currentX","lineWidth","copyList","listCopy","tmpPoint","j","calcDistance","distance","sqrt","round","swap","ind1","floor","random","ind2","tmpX","tmpY","circles","iterations","MAX_ITER","pathList","bestPath","distanceList","tmpPath","acceptanceProbability","currentEnergy","newEnergy","temperature","exp","simulatedAnnealing","T","currentPath","bestEnergy","newPath","shuffle","swapInd","tmp","Path","pathCopy","this","calcFitness","fitness","Population","fittest","fittestValue","sum","pickOne","index","r","GA","eliteOffset","population","normalizeFitness","sortByFitness","generations","bestEverDist","bestEverPath","bestDist","curDist","nextGeneration","newPopulation","order","orderTwo","crossOver","orderA","orderB","cross","visited","Set","add","has","tmpFitness","modalRoot","document","getElementById","Modal","ReactDOM","createPortal","style","position","top","bottom","left","right","display","justifyContent","alignItems","backgroundColor","padding","background","borderRadius","minHeight","margin","minWidth","boxShadow","justifySelf","props","statement","onClick","onClose","React","Component","App","state","drawing","showTutorial","setDistances","setState","closeTutorial","circlesCopy","slice","refs","canvas2","alert","algorithm","evole","best","className","ref","e","addCircle","clientX","clientY","id","selectAlgorithm","resetState","render"],"mappings":"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","file":"static/js/main.9870516f.chunk.js","sourcesContent":["const drawCircle = (canvasRef, x, y) => {\n    const canvas = canvasRef;\n    const ctx = canvas.getContext('2d');\n\n    ctx.strokeStyle = 'black';\n    ctx.beginPath();\n    ctx.arc(x, y, 10, 0, 2 * Math.PI);\n\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    ctx.stroke();\n}\n\nexport default drawCircle;","const clearCanvas = (canvasRef) => {\n    const canvas = canvasRef;\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n}\n\nexport default clearCanvas;","import drawCircle from './drawCircle'\nimport clearCanvas from './clearCanvas'\n\nconst drawTSP = (canvasRef, path) => {\n    const canvas = canvasRef;\n    const ctx = canvas.getContext('2d');\n    const arr = path;\n\n    clearCanvas(canvas);\n\n    ctx.strokeStyle = 'black';\n\n    for (let i = 0; i < arr.length; i++){\n        drawCircle(canvas, arr[i][0], arr[i][1]);\n    }\n\n    for (let i = 0; i < arr.length - 1; i++){\n        ctx.beginPath();\n        ctx.moveTo(arr[i][0], arr[i][1]);\n        ctx.lineTo(arr[i + 1][0], arr[i + 1][1]);\n        ctx.stroke();\n    }\n}\n\nexport default drawTSP;","import drawCircle from './drawCircle'\nimport clearCanvas from './clearCanvas'\n\nconst animateBestPath = (canvasRef, path, doneDrawing) => {\n    const canvas = canvasRef;\n    const ctx = canvas.getContext('2d');\n    const arr = path;\n\n    clearCanvas(canvas);\n\n    let deltaTime = 2000 / arr.length;\n\n    for (let i = 0; i < arr.length; i++){\n        drawCircle(canvas, arr[i][0], arr[i][1]);\n    }\n\n    ctx.strokeStyle = 'red';\n\n    for (let i = 0; i < arr.length - 1; i++) {\n        setTimeout(() => {\n            ctx.beginPath();\n            ctx.moveTo(arr[i][0], arr[i][1]);\n            ctx.lineTo(arr[i + 1][0], arr[i + 1][1]);\n            ctx.stroke();\n\n            if (i === arr.length - 2) {\n                doneDrawing();\n            }\n        }, deltaTime * i);\n    }\n\n    \n}\n\n\nexport default animateBestPath;","const findMinMax = (list) => {\n    let min = list[0];\n    let max = list[0];\n\n    for (let i = 1; i < list.length; i++) {\n        if (list[i] > max) {\n            max = list[i];\n        }\n\n        if (list[i] < min) {\n            min = list[i];\n        }\n    }\n\n    return [min, max];\n}\n\nexport default findMinMax;","const scaleList = (list, min, max, canvasHeight) => {\n    let scaleFactor = canvasHeight / (max - min);\n    console.log(scaleFactor);\n    let scaledList = [];\n\n    for (let i = 0; i < list.length; i++) {\n        scaledList.push((list[i] - min) * scaleFactor);\n        scaledList[i] = canvasHeight - scaledList[i];\n    }\n\n    return scaledList;\n}\n\nexport default scaleList;","import drawTSP from './drawTSP'\nimport animateBestPath from './animateBestPath'\nimport findMinMax from './../Algorithms/findMinMax'\nimport scaleList from './../Algorithms/scaleList'\n\nconst animatePath = (canvasRef, canvas2Ref, paths, distances, updateDistances, doneDrawing) => {\n    const canvas = canvasRef;\n    const path = paths;\n    const canvasHeight = 720;\n    const canvasWidth = 900;\n    var currentDistance;\n    var bestDistance = -1;\n\n    const ctx2 = canvas2Ref.getContext('2d');\n\n    var invalidGraph = false;\n    let [minDist, maxDist] = findMinMax(distances);\n    //Add edge case if minDist === maxDist\n\n    if (minDist !== maxDist) {\n        var scaledValues = scaleList(distances, minDist, maxDist, canvasHeight);\n    }\n    else {\n        invalidGraph = true;\n    }\n    \n    console.log(distances);\n    console.log(scaledValues);\n\n    const delX = canvasWidth / (distances.length - 1);\n\n    let currentX = 0;\n\n    /**\n     * Time = path.length * deltaTime, set Time = 3000ms:\n     * deltaTime = 3000 / path.length\n     */\n    let deltaTime = 3000 / path.length;\n    ctx2.lineWidth = 0.3;\n\n    for (let i = 0; i < path.length; i++) {\n        setTimeout(() => {\n            currentDistance = distances[i];\n\n            if (i !== path.length - 1) {\n                drawTSP(canvas, path[i]);\n                \n                if (bestDistance < 0 || bestDistance > distances[i]) {\n                    bestDistance = distances[i];\n                }\n            }\n            else {\n                animateBestPath(canvas, path[i], doneDrawing);\n            }\n\n            if (!invalidGraph) {\n                if (scaledValues[i] === canvasHeight) {\n                    scaledValues[i] -= 3; //keep it visible\n                }\n\n                if (i === 0) {\n                    ctx2.beginPath();\n                    ctx2.moveTo(currentX, scaledValues[0]);\n                }\n                else {\n                    ctx2.lineTo(currentX, scaledValues[i]);\n                    ctx2.stroke();\n                }\n            }\n            else {\n                if (i === 0) {\n                    ctx2.beginPath();\n                    ctx2.moveTo(currentX, 250);\n                }\n                else {\n                    ctx2.lineTo(currentX, 250);\n                    ctx2.stroke();\n                }\n            }\n            \n\n            currentX += delX;\n\n            updateDistances(currentDistance, bestDistance);\n        }, i * deltaTime);\n    }\n}\n\nexport default animatePath;","function copyList(list) {\n    let listCopy = [];\n\n    for (let i = 0; i < list.length; i++) {\n        let tmpPoint = [];\n\n        for (let j = 0; j < list[i].length; j++) {\n            tmpPoint.push(list[i][j]);\n        }\n\n        listCopy.push(tmpPoint);\n    }\n    \n    return listCopy;\n}\n\nexport default copyList;","const calcDistance = (path) => {\n    let distance = 0;\n    const arr = path;\n\n    for (let i = 1; i < path.length; i++) {\n        distance += Math.sqrt( (arr[i][0] - arr[i - 1][0])**2 + (arr[i][1] - arr[i - 1][1])**2 );\n    }\n\n    distance = Math.round(distance);\n\n    return distance;\n}\n\nexport default calcDistance;","const swap = (list) => {\n\n    if (list.length < 2) {\n        return;\n    }\n\n    let ind1 = Math.floor(Math.random() * list.length);\n    let ind2 = Math.floor(Math.random() * list.length);\n    \n    while (ind2 === ind1) {\n        ind2 = Math.floor(Math.random() * list.length);\n    }\n\n    let tmpX = list[ind1][0];\n    let tmpY = list[ind1][1];\n\n    list[ind1][0] = list[ind2][0];\n    list[ind1][1] = list[ind2][1];\n\n    list[ind2][0] = tmpX;\n    list[ind2][1] = tmpY;\n}\n\nexport default swap;","import copyList from './copyList'\nimport calcDistance from './calcDistance'\nimport swap from './swap'\n\nconst random = (circles, iterations) => {\n    const MAX_ITER = iterations;\n    let pathList = [];\n    let bestPath = [];\n    let distanceList = [];\n    let bestDistance = -1;\n\n    let tmpPath = copyList(circles);\n\n    for (let i = 0; i < MAX_ITER; i++) {\n        swap(tmpPath);\n\n        //console.log(tmpPath);\n        pathList.push(tmpPath);\n        distanceList.push(calcDistance(tmpPath));\n        if (distanceList[i] < bestDistance || bestDistance === -1) {\n            bestDistance = distanceList[i];\n            bestPath = tmpPath;\n        }\n\n        tmpPath = copyList(circles);\n    }\n\n    pathList.push(bestPath);\n    distanceList.push(bestDistance);\n    //console.log(pathList);\n\n    return [pathList, distanceList];\n\n}\n\nexport default random","const acceptanceProbability = (currentEnergy, newEnergy, temperature) => {\n    if (newEnergy < currentEnergy) {\n        return 1.0;\n    }\n    \n    //currentEnergy < newEnergy\n\n    return Math.exp( (currentEnergy - newEnergy) / temperature);\n    //return Math.exp(-(newEnergy - currentEnergy) / temperature);\n    //return 1 / (1 + Math.exp((newEnergy - currentEnergy) / temperature));\n}\n\nexport default acceptanceProbability;","import copyList from './copyList'\nimport calcDistance from './calcDistance'\nimport acceptanceProbability from './acceptanceProbability'\nimport swap from './swap';\n\nconst simulatedAnnealing = (list) => {\n    let T = 100000;\n    const coolingRate = 0.05;\n    let paths = [];\n    let distances = [];\n\n    let currentEnergy = calcDistance(list);\n    let currentPath = copyList(list);\n\n    paths.push(list);\n    distances.push(currentEnergy);\n\n    var bestEnergy = currentEnergy;\n    var bestPath = list;\n\n    while (T > 0.01) {\n\n        let newPath = copyList(currentPath);\n\n        swap(newPath);\n\n        let newEnergy = calcDistance(newPath);\n\n        if (acceptanceProbability(currentEnergy, newEnergy, T) > Math.random()) {\n            currentPath = copyList(newPath);\n            paths.push(currentPath);\n            distances.push(newEnergy);\n\n            currentEnergy = newEnergy;\n\n            if (currentEnergy < bestEnergy) {\n                bestEnergy = currentEnergy;\n                bestPath = currentPath;\n            }\n        }\n\n\n        T = T * (1 - coolingRate);\n    }\n\n    paths.push(bestPath);\n    distances.push(bestEnergy);\n\n    //console.log(paths);\n    //console.log(\"Distances = :\");\n    //console.log(distances);\n\n    return [paths, distances];\n}\n\nexport default simulatedAnnealing;","const shuffle = (list) => {\n    for (let i = 0; i < list.length; i++) {\n        let swapInd = Math.floor(Math.random() * list.length);\n\n        while (swapInd === i) {\n            swapInd = Math.floor(Math.random() * list.length);\n        }\n\n        let tmp = list[i];\n        list[i] = list[swapInd];\n        list[swapInd] = tmp;\n    }\n}\n\nexport default shuffle;","import shuffle from './shuffle'\nimport copyList from './../copyList'\nimport calcDistance from '../calcDistance';\n\nexport default class Path {\n    constructor(path) {\n        let pathCopy = copyList(path);\n        shuffle(pathCopy);\n\n        this.path = pathCopy;\n        this.calcFitness();\n    }\n\n    calcFitness() {\n        this.fitness =  1 / (1 + calcDistance(this.path));\n    }\n}","import Path from './Path'\n\nexport default class Population {\n    constructor(path) {\n        let paths = [];\n\n        for (let i = 0; i < 100; i++) {\n            paths.push(new Path(path));\n        }\n\n        this.paths = paths;\n\n        //console.log(paths);\n    }\n\n    getFittest() {\n        let fittest = this.paths[0];\n        let fittestValue = fittest.fitness;\n\n        for (let i = 1; i < this.paths.length; i++) {\n            if (this.paths[i].fitness > fittestValue) {\n                fittestValue = this.paths[i].fitness;\n                fittest = this.paths[i];\n            }\n        }\n\n        return fittest;\n    }\n\n    normalizeFitness() {\n        let sum = 0;\n\n        for (let i = 0; i < this.paths.length; i++) {\n            sum += this.paths[i].fitness;\n        }\n\n        for (let i = 0; i < this.paths.length; i++) {\n            this.paths[i].fitness = this.paths[i].fitness / sum;\n        }\n    }\n}","import copyList from './../copyList'\n\nconst pickOne = (paths) => {\n    var index = 0;\n    var r = Math.random();\n\n    while (r > 0) {\n        r = r - paths[index].fitness;\n        index++;\n    }\n\n    index--;\n\n    var newPath = copyList(paths[index].path);\n\n    return newPath;\n}\n\nexport default pickOne;","import Population from \"./Population\"\nimport swap from \"../swap\"\nimport calcDistance from \"../calcDistance\"\nimport pickOne from './pickOne'\nimport copyList from \"../copyList\";\n\nexport default class GA {\n    constructor(circles) {\n        this.eliteOffset = 5;\n        this.population = new Population(circles);\n        this.population.normalizeFitness();\n        this.sortByFitness();\n    }\n\n    evole(generations) {\n        let paths = [];\n        let distances = [];\n\n        let bestEverDist = 10000000000;\n        let bestEverPath = [];\n\n        for (let i = 0; i < generations; i++) {\n            let bestDist = 100000000000;\n            let bestPath = [];\n\n            for (let j = 0; j < this.population.paths.length; j++) {\n                let curDist = calcDistance(this.population.paths[j].path);\n\n                if (curDist < bestDist) {\n                    bestDist = curDist;\n                    bestPath = this.population.paths[j].path;\n                }\n\n                if (curDist < bestEverDist) {\n                    bestEverDist = curDist;\n                    bestEverPath = this.population.paths[j].path;\n                }\n            }\n            \n\n            paths.push(bestPath);\n            distances.push(bestDist);\n\n            this.nextGeneration();\n        }\n\n        paths.push(bestEverPath);\n        distances.push(bestEverDist);\n\n        return [paths, distances];\n    }\n\n    nextGeneration() {\n        var newPopulation = [];\n\n        for (let i = 0; i < this.eliteOffset; i++) {\n            newPopulation.push(copyList(this.population.paths[i].path));\n        }\n\n        for (let i = 0; i < this.population.paths.length - this.eliteOffset; i++) {\n            \n            var order = pickOne(this.population.paths);\n\n            if (Math.random() > 0.8) {\n                var orderTwo = pickOne(this.population.paths);\n\n                order = this.crossOver(order, orderTwo);\n            }\n            else {\n                swap(order);\n            }\n            \n            newPopulation.push(order);\n        }\n\n        for (let i = 0; i < this.population.paths.length; i++) {\n            this.population.paths[i].path = newPopulation[i];\n            this.population.paths[i].calcFitness();\n        }\n\n        this.population.normalizeFitness();\n        this.sortByFitness();\n    }\n\n    crossOver(orderA, orderB) {\n        let ind1 = Math.floor(Math.random() * orderA.length);\n        let ind2 = Math.floor(Math.random() * orderA.length);\n        var cross = [];\n\n        while (ind2 === ind1) {\n            ind2 = Math.floor(Math.random() * orderA.length);\n        }\n\n        if (ind1 > ind2) {\n            let tmp = ind2;\n            ind2 = ind1;\n            ind1 = tmp;\n        }\n\n        let visited = new Set();\n        for (let i = ind1; i < ind2; i++) {\n            cross.push(orderA[i]);\n            visited.add(\"\" + orderA[i]); //new\n        }\n\n        for (let i = 0; i < orderB.length; i++) {\n            if (!visited.has(\"\" + orderB[i])) {\n                cross.push(orderB[i]);\n                visited.add(\"\" + orderB[i]);\n            }\n        }\n\n        for (let i = 0; i < orderA.length; i++) {\n            if (!visited.has(\"\" + orderA[i])) {\n                cross.push(orderA[i]);\n            }\n        }\n\n        return cross;\n    }\n\n    sortByFitness() {\n        const population = this.population;\n\n        for (let i = 0; i < population.paths.length - 1; i++) {\n            for (let j = i + 1; j < population.paths.length; j++) {\n                if (population.paths[j].fitness > population.paths[i].fitness) {\n                    let tmpPath = population.paths[i].path;\n                    let tmpFitness = population.paths[i].fitness;\n\n                    population.paths[i].path = population.paths[j].path;\n                    population.paths[i].fitness = population.paths[j].fitness;\n\n                    population.paths[j].path = tmpPath;\n                    population.paths[j].fitness = tmpFitness;\n\n                }\n            }\n        }\n    }\n}","import React from 'react';\nimport ReactDOM, { render } from 'react-dom';\n\nconst modalRoot = document.getElementById(\"modal-root\");\n\n\nclass Modal extends React.Component {\n    render() {\n        return ReactDOM.createPortal(\n            <div\n            style={{\n            position: \"absolute\",\n            top: \"0\",\n            bottom: \"0\",\n            left: \"0\",\n            right: \"0\",\n            display: \"grid\",\n            justifyContent: \"center\",\n            alignItems: \"center\",\n            backgroundColor: \"rgba(0,0,0,0.3)\"\n            }}\n        >\n            <div\n            style={{\n                padding: 20,\n                background: \"#fff\",\n                borderRadius: \"2px\",\n                display: \"inline-block\",\n                minHeight: \"800px\",\n                margin: \"1rem\",\n                position: \"relative\",\n                minWidth: \"800px\",\n                boxShadow: \"0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23)\",\n                justifySelf: \"center\"\n            }}\n            >\n            {this.props.statement}\n            <hr />\n            <p>Place destinations on the canvas to the left and then select an algorithm!</p>\n            <button onClick={this.props.onClose}>Close</button>\n            </div>\n        </div>,\n        modalRoot\n        );\n    }\n}\n\nexport default Modal;","import React from 'react';\nimport './App.css';\nimport drawCircle from './Animations/drawCircle'\nimport clearCanvas from './Animations/clearCanvas'\nimport animatePath from './Animations/animatePath'\nimport random from './Algorithms/random'\nimport swap from './Algorithms/swap'\nimport simulatedAnnealing from './Algorithms/simulatedAnnealing'\nimport GA from './Algorithms/Genetic_Algorithm/GA'\nimport Modal from './Modal'\n//import Button from 'react-bootstrap/Button'\n\n\n//TODO: set animation time to be fixed to some time: calculating how many paths there are in the list.\n//TODO: Save the top 5 paths from previous generation.\n\nclass App extends React.Component {\n    state = {\n        circles : [],\n        bestPath : [],\n        bestDistance : -1,\n        distance : null,\n        drawing: false,\n        showTutorial: true\n    }\n\n    /**\n     * \n     * @param {int} x   x coordinate of the circle\n     * @param {int} y   y coordinate of the circle\n     */\n    addCircle(x, y) {\n        let circlesCopy = this.state.circles.slice();\n        circlesCopy.push([x, y]);\n\n        //shuffle list of circle locations\n        swap(circlesCopy);\n\n        this.setState({circles : circlesCopy});\n        drawCircle(this.refs.canvas, x, y);\n    }\n\n    /**\n     * @param {double} currentDistance  distance of the current path\n     * @param {double} bestDistance     distance of the best path\n     */\n    setDistances = (currentDistance, bestDistance) => {\n        this.setState({distance : currentDistance,\n                    bestDistance : bestDistance});\n        \n    }\n    \n    /**\n     * Resets state and clears the canvas\n     */\n    resetState() {\n        if (this.state.drawing === true) {\n            alert('Wait for animation to finish before resetting!');\n            return;\n        }\n\n        clearCanvas(this.refs.canvas);\n        clearCanvas(this.refs.canvas2);\n\n        this.setState({circles : [], \n                    bestDistance : -1,\n                    distance : null,\n                    drawing : false}\n                    );\n    }\n\n    /**\n     * Changes the state of drawing to false for when the animations are finished.\n     */\n    doneDrawing = () => {\n        this.setState({drawing : false});\n    }\n\n\n    /**\n     * Method to close the tutorial window\n     */\n    closeTutorial = () => {\n        this.setState({showTutorial : false});\n    }\n\n    /**\n     * Method that handles which algorithm to use to solve the TSP.\n     * \n     * @param {String} algorithm    Name of the algorithm to be used\n     */\n    selectAlgorithm(algorithm) {\n\n        //check list size\n        if (this.state.circles.length < 2) {\n            alert('Must contain at least 2 or more circles to find paths');\n            return;\n        }\n        else if (this.state.drawing === true) {\n            alert('Wait for animation to finish before selecting another algorithm!');\n            return;\n        }\n\n        clearCanvas(this.refs.canvas2);\n        this.setState({drawing : true});\n\n        //reset distances\n        this.setDistances(null, -1);\n\n        var paths, distances;\n        \n        if (algorithm === \"SA\") {\n            [paths, distances] = simulatedAnnealing(this.state.circles);\n        }\n        else if (algorithm === \"randomSwap\") {\n            [paths, distances] = random(this.state.circles, 50);\n        }\n        else if (algorithm === \"GA\") {\n            let ga = new GA(this.state.circles);\n            [paths, distances] = ga.evole(100);\n        }\n\n        animatePath(this.refs.canvas, this.refs.canvas2, paths, distances, this.setDistances, this.doneDrawing);\n    }\n\n    /**\n     * Render method\n     */\n    render() {\n        var best;\n\n\n        if (this.state.bestDistance === -1){\n            best = \"\";\n        }\n        else {\n            best = this.state.bestDistance;\n        }\n\n        return (\n            <div className=\"container\">\n                <div>\n                    <canvas ref=\"canvas\" width={880} height={800}\n                            onClick={(e) => this.addCircle(e.clientX, e.clientY)}\n                    />\n\n                    <div id=\"div2\">\n                        <p>Distance Graph:</p>\n                        <canvas ref=\"canvas2\" id=\"distancegraph\" width={900} height={720}\n                        />\n                    </div>\n                </div>\n\n                <div id=\"utilities\">\n                    <div id=\"buttons\">\n                        <button className=\"btn\" onClick={() => this.selectAlgorithm('randomSwap')}>Random Swap</button>\n                        <button className=\"btn\" onClick={() => this.selectAlgorithm('SA')}>Simulated Annealing</button>\n                        <button className=\"btn\" onClick={() => this.selectAlgorithm('GA')}>Genetic Algorithm</button>\n                        <button className=\"btn\" onClick={() => this.resetState()}>Reset</button>\n                    </div>\n\n                    <div id=\"scoreInfo\">\n                        <p className=\"scoreboard\">Current Distance: {this.state.distance}</p>\n                        <p className=\"scoreboard\">Best Distance: {best}</p>\n                    </div>\n                    \n                </div>\n                \n\n                {this.state.showTutorial ? (\n                    <Modal onClose={this.closeTutorial} statement={\"Tutorial:\"}/>\n                ) : null}\n            </div>\n            \n\n        );\n    }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n//import 'bootstrap/dist/css/bootstrap.min.css';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}