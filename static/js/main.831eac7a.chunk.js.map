{"version":3,"sources":["Animations/drawCircle.js","Animations/clearCanvas.js","Animations/drawTSP.js","Animations/animateBestPath.js","Animations/animatePath.js","Algorithms/copyList.js","Algorithms/calcDistance.js","Algorithms/random.js","Algorithms/acceptanceProbability.js","Algorithms/simulatedAnnealing.js","Canvas.js","index.js"],"names":["drawCircle","canvasRef","x","y","ctx","getContext","strokeStyle","beginPath","arc","Math","PI","fillStyle","fill","stroke","clearCanvas","canvas","clearRect","width","height","drawTSP","path","arr","i","length","moveTo","lineTo","animateBestPath","setTimeout","animatePath","paths","distances","updateDistances","currentDistance","bestDistance","copyList","list","listCopy","tmpPoint","j","push","calcDistance","distance","sqrt","round","random","circles","iterations","MAX_ITER","pathList","bestPath","distanceList","tmpPath","ind1","floor","ind2","tmpX","tmpY","acceptanceProbability","currentEnergy","newEnergy","temperature","exp","simulatedAnnealing","T","currentPath","bestEnergy","newPath","console","log","Canvas","state","drawing","setDistances","setState","circlesCopy","this","slice","refs","alert","best","className","ref","onClick","e","addCircle","clientX","clientY","randomSwap","resetState","SA","React","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.831eac7a.chunk.js","sourcesContent":["const drawCircle = (canvasRef, x, y) => {\n    const canvas = canvasRef;\n    const ctx = canvas.getContext('2d');\n\n    ctx.strokeStyle = 'black';\n    ctx.beginPath();\n    ctx.arc(x, y, 10, 0, 2 * Math.PI);\n\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    ctx.stroke();\n}\n\nexport default drawCircle;","const clearCanvas = (canvasRef) => {\n    const canvas = canvasRef;\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n}\n\nexport default clearCanvas;","import drawCircle from './drawCircle'\nimport clearCanvas from './clearCanvas'\n\nconst drawTSP = (canvasRef, path) => {\n    const canvas = canvasRef;\n    const ctx = canvas.getContext('2d');\n    const arr = path;\n\n    clearCanvas(canvas);\n\n    ctx.strokeStyle = 'black';\n\n    for (let i = 0; i < arr.length; i++){\n        drawCircle(canvas, arr[i][0], arr[i][1]);\n    }\n\n    for (let i = 0; i < arr.length - 1; i++){\n        ctx.beginPath();\n        ctx.moveTo(arr[i][0], arr[i][1]);\n        ctx.lineTo(arr[i + 1][0], arr[i + 1][1]);\n        ctx.stroke();\n    }\n}\n\nexport default drawTSP;","import drawCircle from './drawCircle'\nimport clearCanvas from './clearCanvas'\n\nconst animateBestPath = (canvasRef, path) => {\n    const canvas = canvasRef;\n    const ctx = canvas.getContext('2d');\n    const arr = path;\n\n    clearCanvas(canvas);\n\n    for (let i = 0; i < arr.length; i++){\n        drawCircle(canvas, arr[i][0], arr[i][1]);\n    }\n\n    ctx.strokeStyle = 'red';\n\n    for (let i = 0; i < arr.length - 1; i++) {\n        setTimeout(() => {\n            ctx.beginPath();\n            ctx.moveTo(arr[i][0], arr[i][1]);\n            ctx.lineTo(arr[i + 1][0], arr[i + 1][1]);\n            ctx.stroke();\n        }, 200 * i);\n    }\n}\n\n\nexport default animateBestPath;","import drawTSP from './drawTSP'\nimport animateBestPath from './animateBestPath';\n\nconst animatePath = (canvasRef, paths, distances, updateDistances) => {\n    const canvas = canvasRef;\n    const path = paths;\n    var currentDistance;\n    var bestDistance = -1;\n\n    for (let i = 0; i < path.length; i++) {\n        setTimeout(() => {\n            currentDistance = distances[i];\n\n            if (i !== path.length - 1) {\n                drawTSP(canvas, path[i]);\n                \n                if (bestDistance < 0 || bestDistance > distances[i]) {\n                    bestDistance = distances[i];\n                }\n            }\n            else {\n                animateBestPath(canvas, path[i]);\n            }\n\n            updateDistances(currentDistance, bestDistance);\n        }, i * 30);\n    }\n}\n\nexport default animatePath;","function copyList(list) {\n    let listCopy = [];\n\n    for (let i = 0; i < list.length; i++) {\n        let tmpPoint = [];\n\n        for (let j = 0; j < list[i].length; j++) {\n            tmpPoint.push(list[i][j]);\n        }\n\n        listCopy.push(tmpPoint);\n    }\n    \n    return listCopy;\n}\n\nexport default copyList;","const calcDistance = (path) => {\n    let distance = 0;\n    const arr = path;\n\n    for (let i = 1; i < path.length; i++) {\n        distance += Math.sqrt( (arr[i][0] - arr[i - 1][0])**2 + (arr[i][1] - arr[i - 1][1])**2 );\n    }\n\n    distance = Math.round(distance);\n\n    return distance;\n}\n\nexport default calcDistance;","import copyList from './copyList'\nimport calcDistance from './calcDistance'\n\nconst random = (circles, iterations) => {\n    const MAX_ITER = iterations;\n    let pathList = [];\n    let bestPath = [];\n    let distanceList = [];\n    let bestDistance = -1;\n\n    let tmpPath = copyList(circles);\n\n    for (let i = 0; i < MAX_ITER; i++) {\n        let ind1 = Math.floor(Math.random() * tmpPath.length);\n        let ind2 = Math.floor(Math.random() * tmpPath.length);\n        \n        while (ind2 === ind1) {\n            ind2 = Math.floor(Math.random() * tmpPath.length);\n        }\n\n        let tmpX = tmpPath[ind1][0];\n        let tmpY = tmpPath[ind1][1];\n\n        tmpPath[ind1][0] = tmpPath[ind2][0];\n        tmpPath[ind1][1] = tmpPath[ind2][1];\n\n        tmpPath[ind2][0] = tmpX;\n        tmpPath[ind2][1] = tmpY;\n\n        //console.log(tmpPath);\n        pathList.push(tmpPath);\n        distanceList.push(calcDistance(tmpPath));\n        if (distanceList[i] < bestDistance || bestDistance === -1) {\n            bestDistance = distanceList[i];\n            bestPath = tmpPath;\n        }\n\n        tmpPath = copyList(circles);\n    }\n\n    pathList.push(bestPath);\n    distanceList.push(bestDistance);\n    //console.log(pathList);\n\n    return [pathList, distanceList];\n\n}\n\nexport default random","const acceptanceProbability = (currentEnergy, newEnergy, temperature) => {\n    if (newEnergy < currentEnergy) {\n        return 1.0;\n    }\n    \n    return Math.exp((newEnergy - currentEnergy) / temperature);\n    \n}\n\nexport default acceptanceProbability;","import copyList from './copyList'\nimport calcDistance from './calcDistance'\nimport acceptanceProbability from './acceptanceProbability'\n\nconst simulatedAnnealing = (list) => {\n    let T = 100000;\n    const coolingRate = 0.1;\n    let paths = [];\n    let distances = [];\n\n    let currentEnergy = calcDistance(list);\n    let currentPath = copyList(list);\n\n    paths.push(list);\n    distances.push(currentEnergy);\n\n    var bestEnergy = currentEnergy;\n    var bestPath = list;\n\n    while (T > 1) {\n\n        let newPath = copyList(currentPath);\n\n        let ind1 = Math.floor(Math.random() * newPath.length);\n        let ind2 = Math.floor(Math.random() * newPath.length);\n        \n        while (ind2 === ind1) {\n            ind2 = Math.floor(Math.random() * newPath.length);\n        }\n\n        let tmpX = newPath[ind1][0];\n        let tmpY = newPath[ind1][1];\n\n        newPath[ind1][0] = newPath[ind2][0];\n        newPath[ind1][1] = newPath[ind2][1];\n\n        newPath[ind2][0] = tmpX;\n        newPath[ind2][1] = tmpY;\n\n        let newEnergy = calcDistance(newPath);\n\n        if (acceptanceProbability(currentEnergy, newEnergy, T) > Math.random()) {\n            currentPath = newPath;\n            paths.push(currentPath);\n            distances.push(currentEnergy)\n\n            currentEnergy = newEnergy;\n\n            if (currentEnergy < bestEnergy) {\n                bestEnergy = currentEnergy;\n                bestPath = currentPath;\n            }\n        }\n\n\n        T = T * (1 - coolingRate);\n    }\n\n    paths.push(bestPath);\n    distances.push(bestEnergy);\n\n    //console.log(paths);\n    console.log(\"Distances = :\");\n    console.log(distances);\n\n    return [paths, distances];\n}\n\nexport default simulatedAnnealing;","import React from 'react';\nimport './App.css';\nimport drawCircle from './Animations/drawCircle'\nimport clearCanvas from './Animations/clearCanvas'\nimport animatePath from './Animations/animatePath'\nimport random from './Algorithms/random'\nimport simulatedAnnealing from './Algorithms/simulatedAnnealing'\n\n\nclass Canvas extends React.Component {\n    state = {\n        circles : [],\n        bestPath : [],\n        bestDistance : -1,\n        distance : null,\n        drawing: false,\n    }\n\n    addCircle(x, y) {\n        let circlesCopy = this.state.circles.slice();\n        circlesCopy.push([x, y]);\n        this.setState({circles : circlesCopy});\n        drawCircle(this.refs.canvas, x, y);\n    }\n\n    setDistances = (currentDistance, bestDistance) => {\n        this.setState({distance : currentDistance});\n        this.setState({bestDistance : bestDistance});\n    }\n    //try to change this to multiple state changes in one line, seems like this can be improved\n    resetState() {\n        clearCanvas(this.refs.canvas);\n\n        this.setState({circles : [], \n                    bestDistance : -1,\n                    distance : null,\n                    drawing : false}\n                    );\n    }\n\n    randomSwap() {\n        //get the lists\n        if (this.state.circles.length < 2) {\n            alert('Must contain at least 2 or more circles to find paths');\n            return;\n        }\n\n        this.setDistances(null, -1);\n        const [paths, distances] = random(this.state.circles, 50);\n\n        animatePath(this.refs.canvas, paths, distances, this.setDistances);\n\n        //with setDistances as normal function we needed to bind(this). \n        //with setDistances as arrow function: not needed to bind this.\n\n    }\n\n    SA() {\n        if (this.state.circles.length < 2) {\n            alert('Must contain at least 2 or more circles to find paths');\n            return;\n        }\n\n        this.setDistances(null, -1);\n        const [paths, distances] = simulatedAnnealing(this.state.circles);\n\n        animatePath(this.refs.canvas, paths, distances, this.setDistances);\n    }\n\n    render() {\n        var best;\n\n        if (this.state.bestDistance === -1){\n            best = \"\";\n        }\n        else {\n            best = this.state.bestDistance;\n        }\n\n        return (\n            <div className=\"container\">\n                <div>\n                    <canvas ref=\"canvas\" width={1000} height={1000}\n                            onClick={(e) => this.addCircle(e.clientX, e.clientY)}\n                    />\n\n                    \n                </div>\n\n                <p className=\"scoreboard\">Current Distance: {this.state.distance}</p>\n                <p className=\"scoreboard\">Best Distance: {best}</p>\n\n                <div>\n                    <button className=\"btn\" onClick={() => this.randomSwap()}>Solve</button>\n                    <button className=\"btn\" onClick={() => this.resetState()}>Reset</button>\n                    <button className=\"btn\" onClick={() => this.SA()}>SA</button>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default Canvas;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Canvas from './Canvas';\n\nReactDOM.render(<Canvas />, document.getElementById('root'));\n"],"sourceRoot":""}