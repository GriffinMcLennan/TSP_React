{"version":3,"sources":["Animations/drawCircle.js","Animations/clearCanvas.js","Animations/drawTSP.js","Animations/animateBestPath.js","Algorithms/findMinMax.js","Algorithms/scaleList.js","Animations/animatePath.js","Algorithms/copyList.js","Algorithms/calcDistance.js","Algorithms/swap.js","Algorithms/random.js","Algorithms/acceptanceProbability.js","Algorithms/simulatedAnnealing.js","Algorithms/Genetic_Algorithm/shuffle.js","Algorithms/Genetic_Algorithm/Path.js","Algorithms/Genetic_Algorithm/Population.js","Algorithms/Genetic_Algorithm/pickOne.js","Algorithms/Genetic_Algorithm/GA.js","Canvas.js","index.js"],"names":["drawCircle","canvasRef","x","y","ctx","getContext","strokeStyle","beginPath","arc","Math","PI","fillStyle","fill","stroke","clearCanvas","canvas","clearRect","width","height","drawTSP","path","arr","i","length","moveTo","lineTo","animateBestPath","doneDrawing","deltaTime","setTimeout","findMinMax","list","min","max","scaleList","canvasHeight","scaleFactor","console","log","scaledList","push","animatePath","canvas2Ref","paths","distances","updateDistances","currentDistance","bestDistance","ctx2","minDist","maxDist","scaledValues","delX","currentX","copyList","listCopy","tmpPoint","j","calcDistance","distance","sqrt","round","swap","ind1","floor","random","ind2","tmpX","tmpY","circles","iterations","MAX_ITER","pathList","bestPath","distanceList","tmpPath","acceptanceProbability","currentEnergy","newEnergy","temperature","exp","simulatedAnnealing","T","currentPath","bestEnergy","newPath","shuffle","swapInd","tmp","Path","pathCopy","this","calcFitness","fitness","Population","fittest","fittestValue","sum","pickOne","index","r","GA","eliteOffset","population","normalizeFitness","sortByFitness","generations","bestEverDist","bestEverPath","bestDist","curDist","nextGeneration","newPopulation","order","orderTwo","crossOver","orderA","orderB","cross","contains","element","tmpFitness","Canvas","state","drawing","setDistances","setState","circlesCopy","slice","refs","canvas2","alert","algorithm","evole","best","className","ref","onClick","e","addCircle","clientX","clientY","id","selectAlgorithm","resetState","React","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.3a9aa466.chunk.js","sourcesContent":["const drawCircle = (canvasRef, x, y) => {\n    const canvas = canvasRef;\n    const ctx = canvas.getContext('2d');\n\n    ctx.strokeStyle = 'black';\n    ctx.beginPath();\n    ctx.arc(x, y, 10, 0, 2 * Math.PI);\n\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    ctx.stroke();\n}\n\nexport default drawCircle;","const clearCanvas = (canvasRef) => {\n    const canvas = canvasRef;\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n}\n\nexport default clearCanvas;","import drawCircle from './drawCircle'\nimport clearCanvas from './clearCanvas'\n\nconst drawTSP = (canvasRef, path) => {\n    const canvas = canvasRef;\n    const ctx = canvas.getContext('2d');\n    const arr = path;\n\n    clearCanvas(canvas);\n\n    ctx.strokeStyle = 'black';\n\n    for (let i = 0; i < arr.length; i++){\n        drawCircle(canvas, arr[i][0], arr[i][1]);\n    }\n\n    for (let i = 0; i < arr.length - 1; i++){\n        ctx.beginPath();\n        ctx.moveTo(arr[i][0], arr[i][1]);\n        ctx.lineTo(arr[i + 1][0], arr[i + 1][1]);\n        ctx.stroke();\n    }\n}\n\nexport default drawTSP;","import drawCircle from './drawCircle'\nimport clearCanvas from './clearCanvas'\n\nconst animateBestPath = (canvasRef, path, doneDrawing) => {\n    const canvas = canvasRef;\n    const ctx = canvas.getContext('2d');\n    const arr = path;\n\n    clearCanvas(canvas);\n\n    let deltaTime = 2000 / arr.length;\n\n    for (let i = 0; i < arr.length; i++){\n        drawCircle(canvas, arr[i][0], arr[i][1]);\n    }\n\n    ctx.strokeStyle = 'red';\n\n    for (let i = 0; i < arr.length - 1; i++) {\n        setTimeout(() => {\n            ctx.beginPath();\n            ctx.moveTo(arr[i][0], arr[i][1]);\n            ctx.lineTo(arr[i + 1][0], arr[i + 1][1]);\n            ctx.stroke();\n\n            if (i === arr.length - 2) {\n                doneDrawing();\n            }\n        }, deltaTime * i);\n    }\n\n    \n}\n\n\nexport default animateBestPath;","const findMinMax = (list) => {\n    let min = list[0];\n    let max = list[0];\n\n    for (let i = 1; i < list.length; i++) {\n        if (list[i] > max) {\n            max = list[i];\n        }\n\n        if (list[i] < min) {\n            min = list[i];\n        }\n    }\n\n    return [min, max];\n}\n\nexport default findMinMax;","const scaleList = (list, min, max, canvasHeight) => {\n    let scaleFactor = canvasHeight / (max - min);\n    console.log(scaleFactor);\n    let scaledList = [];\n\n    for (let i = 0; i < list.length; i++) {\n        scaledList.push((list[i] - min) * scaleFactor);\n        scaledList[i] = canvasHeight - scaledList[i];\n    }\n\n    return scaledList;\n}\n\nexport default scaleList;","import drawTSP from './drawTSP'\nimport animateBestPath from './animateBestPath'\nimport findMinMax from './../Algorithms/findMinMax'\nimport scaleList from './../Algorithms/scaleList'\n\nconst animatePath = (canvasRef, canvas2Ref, paths, distances, updateDistances, doneDrawing) => {\n    const canvas = canvasRef;\n    const path = paths;\n    const canvasHeight = 500;\n    const canvasWidth = 500;\n    var currentDistance;\n    var bestDistance = -1;\n\n    const ctx2 = canvas2Ref.getContext('2d');\n\n    let [minDist, maxDist] = findMinMax(distances);\n    //Add edge case if minDist === maxDist\n\n    let scaledValues = scaleList(distances, minDist, maxDist, canvasHeight);\n    console.log(distances);\n    console.log(scaledValues);\n\n    const delX = canvasWidth / (scaledValues.length - 1);\n\n    let currentX = 0;\n\n    /**\n     * Time = path.length * deltaTime, set Time = 3000ms:\n     * deltaTime = 3000 / path.length\n     */\n    let deltaTime = 3000 / path.length;\n\n    for (let i = 0; i < path.length; i++) {\n        setTimeout(() => {\n            currentDistance = distances[i];\n\n            if (i !== path.length - 1) {\n                drawTSP(canvas, path[i]);\n                \n                if (bestDistance < 0 || bestDistance > distances[i]) {\n                    bestDistance = distances[i];\n                }\n            }\n            else {\n                animateBestPath(canvas, path[i], doneDrawing);\n            }\n\n            if (i === 0) {\n                ctx2.beginPath();\n                ctx2.moveTo(currentX, scaledValues[0]);\n            }\n            else {\n                ctx2.lineTo(currentX, scaledValues[i]);\n                ctx2.stroke();\n            }\n\n            currentX += delX;\n\n            updateDistances(currentDistance, bestDistance);\n        }, i * deltaTime);\n    }\n}\n\nexport default animatePath;","function copyList(list) {\n    let listCopy = [];\n\n    for (let i = 0; i < list.length; i++) {\n        let tmpPoint = [];\n\n        for (let j = 0; j < list[i].length; j++) {\n            tmpPoint.push(list[i][j]);\n        }\n\n        listCopy.push(tmpPoint);\n    }\n    \n    return listCopy;\n}\n\nexport default copyList;","const calcDistance = (path) => {\n    let distance = 0;\n    const arr = path;\n\n    for (let i = 1; i < path.length; i++) {\n        distance += Math.sqrt( (arr[i][0] - arr[i - 1][0])**2 + (arr[i][1] - arr[i - 1][1])**2 );\n    }\n\n    distance = Math.round(distance);\n\n    return distance;\n}\n\nexport default calcDistance;","const swap = (list) => {\n\n    if (list.length < 2) {\n        return;\n    }\n\n    let ind1 = Math.floor(Math.random() * list.length);\n    let ind2 = Math.floor(Math.random() * list.length);\n    \n    while (ind2 === ind1) {\n        ind2 = Math.floor(Math.random() * list.length);\n    }\n\n    let tmpX = list[ind1][0];\n    let tmpY = list[ind1][1];\n\n    list[ind1][0] = list[ind2][0];\n    list[ind1][1] = list[ind2][1];\n\n    list[ind2][0] = tmpX;\n    list[ind2][1] = tmpY;\n}\n\nexport default swap;","import copyList from './copyList'\nimport calcDistance from './calcDistance'\nimport swap from './swap'\n\nconst random = (circles, iterations) => {\n    const MAX_ITER = iterations;\n    let pathList = [];\n    let bestPath = [];\n    let distanceList = [];\n    let bestDistance = -1;\n\n    let tmpPath = copyList(circles);\n\n    for (let i = 0; i < MAX_ITER; i++) {\n        swap(tmpPath);\n\n        //console.log(tmpPath);\n        pathList.push(tmpPath);\n        distanceList.push(calcDistance(tmpPath));\n        if (distanceList[i] < bestDistance || bestDistance === -1) {\n            bestDistance = distanceList[i];\n            bestPath = tmpPath;\n        }\n\n        tmpPath = copyList(circles);\n    }\n\n    pathList.push(bestPath);\n    distanceList.push(bestDistance);\n    //console.log(pathList);\n\n    return [pathList, distanceList];\n\n}\n\nexport default random","const acceptanceProbability = (currentEnergy, newEnergy, temperature) => {\n    if (newEnergy < currentEnergy) {\n        return 1.0;\n    }\n    \n    //currentEnergy < newEnergy\n\n    return Math.exp( (currentEnergy - newEnergy) / temperature);\n    //return Math.exp(-(newEnergy - currentEnergy) / temperature);\n    //return 1 / (1 + Math.exp((newEnergy - currentEnergy) / temperature));\n}\n\nexport default acceptanceProbability;","import copyList from './copyList'\nimport calcDistance from './calcDistance'\nimport acceptanceProbability from './acceptanceProbability'\nimport swap from './swap';\n\nconst simulatedAnnealing = (list) => {\n    let T = 100000;\n    const coolingRate = 0.05;\n    let paths = [];\n    let distances = [];\n\n    let currentEnergy = calcDistance(list);\n    let currentPath = copyList(list);\n\n    paths.push(list);\n    distances.push(currentEnergy);\n\n    var bestEnergy = currentEnergy;\n    var bestPath = list;\n\n    while (T > 0.01) {\n\n        let newPath = copyList(currentPath);\n\n        swap(newPath);\n\n        let newEnergy = calcDistance(newPath);\n\n        if (acceptanceProbability(currentEnergy, newEnergy, T) > Math.random()) {\n            currentPath = copyList(newPath);\n            paths.push(currentPath);\n            distances.push(newEnergy);\n\n            currentEnergy = newEnergy;\n\n            if (currentEnergy < bestEnergy) {\n                bestEnergy = currentEnergy;\n                bestPath = currentPath;\n            }\n        }\n\n\n        T = T * (1 - coolingRate);\n    }\n\n    paths.push(bestPath);\n    distances.push(bestEnergy);\n\n    //console.log(paths);\n    //console.log(\"Distances = :\");\n    //console.log(distances);\n\n    return [paths, distances];\n}\n\nexport default simulatedAnnealing;","const shuffle = (list) => {\n    for (let i = 0; i < list.length; i++) {\n        let swapInd = Math.floor(Math.random() * list.length);\n\n        while (swapInd === i) {\n            swapInd = Math.floor(Math.random() * list.length);\n        }\n\n        let tmp = list[i];\n        list[i] = list[swapInd];\n        list[swapInd] = tmp;\n    }\n}\n\nexport default shuffle;","import shuffle from './shuffle'\nimport copyList from './../copyList'\nimport calcDistance from '../calcDistance';\n\nexport default class Path {\n    constructor(path) {\n        let pathCopy = copyList(path);\n        shuffle(pathCopy);\n\n        this.path = pathCopy;\n        this.calcFitness();\n    }\n\n    calcFitness() {\n        this.fitness =  1 / (1 + calcDistance(this.path));\n    }\n}","import Path from './Path'\n\nexport default class Population {\n    constructor(path) {\n        let paths = [];\n\n        for (let i = 0; i < 100; i++) {\n            paths.push(new Path(path));\n        }\n\n        this.paths = paths;\n\n        //console.log(paths);\n    }\n\n    getFittest() {\n        let fittest = this.paths[0];\n        let fittestValue = fittest.fitness;\n\n        for (let i = 1; i < this.paths.length; i++) {\n            if (this.paths[i].fitness > fittestValue) {\n                fittestValue = this.paths[i].fitness;\n                fittest = this.paths[i];\n            }\n        }\n\n        return fittest;\n    }\n\n    normalizeFitness() {\n        let sum = 0;\n\n        for (let i = 0; i < this.paths.length; i++) {\n            sum += this.paths[i].fitness;\n        }\n\n        for (let i = 0; i < this.paths.length; i++) {\n            this.paths[i].fitness = this.paths[i].fitness / sum;\n        }\n    }\n}","import copyList from './../copyList'\n\nconst pickOne = (paths) => {\n    var index = 0;\n    var r = Math.random();\n\n    while (r > 0) {\n        r = r - paths[index].fitness;\n        index++;\n    }\n\n    index--;\n\n    var newPath = copyList(paths[index].path);\n\n    return newPath;\n}\n\nexport default pickOne;","import Population from \"./Population\"\nimport swap from \"../swap\"\nimport calcDistance from \"../calcDistance\"\nimport pickOne from './pickOne'\nimport copyList from \"../copyList\";\n\nexport default class GA {\n    constructor(circles) {\n        this.eliteOffset = 5;\n        this.population = new Population(circles);\n        this.population.normalizeFitness();\n        this.sortByFitness();\n    }\n\n    evole(generations) {\n        let paths = [];\n        let distances = [];\n\n        let bestEverDist = 10000000000;\n        let bestEverPath = [];\n\n        for (let i = 0; i < generations; i++) {\n            let bestDist = 100000000000;\n            let bestPath = [];\n\n            for (let j = 0; j < this.population.paths.length; j++) {\n                let curDist = calcDistance(this.population.paths[j].path);\n\n                if (curDist < bestDist) {\n                    bestDist = curDist;\n                    bestPath = this.population.paths[j].path;\n                }\n\n                if (curDist < bestEverDist) {\n                    bestEverDist = curDist;\n                    bestEverPath = this.population.paths[j].path;\n                }\n            }\n            \n\n            paths.push(bestPath);\n            distances.push(bestDist);\n\n            this.nextGeneration();\n        }\n\n        paths.push(bestEverPath);\n        distances.push(bestEverDist);\n\n        return [paths, distances];\n    }\n\n    nextGeneration() {\n        var newPopulation = [];\n\n        for (let i = 0; i < this.eliteOffset; i++) {\n            newPopulation.push(copyList(this.population.paths[i].path));\n        }\n\n        for (let i = 0; i < this.population.paths.length - this.eliteOffset; i++) {\n            \n            var order = pickOne(this.population.paths);\n\n            if (Math.random() > 0.8) {\n                var orderTwo = pickOne(this.population.paths);\n\n                order = this.crossOver(order, orderTwo);\n            }\n            else {\n                swap(order);\n            }\n            \n            newPopulation.push(order);\n        }\n\n        for (let i = 0; i < this.population.paths.length; i++) {\n            this.population.paths[i].path = newPopulation[i];\n            this.population.paths[i].calcFitness();\n        }\n\n        this.population.normalizeFitness();\n        this.sortByFitness();\n    }\n\n    crossOver(orderA, orderB) {\n        let ind1 = Math.floor(Math.random() * orderA.length);\n        let ind2 = Math.floor(Math.random() * orderA.length);\n        var cross = [];\n\n        while (ind2 === ind1) {\n            ind2 = Math.floor(Math.random() * orderA.length);\n        }\n\n        if (ind1 > ind2) {\n            let tmp = ind2;\n            ind2 = ind1;\n            ind1 = tmp;\n        }\n\n        for (let i = ind1; i < ind2; i++) {\n            cross.push(orderA[i]);\n        }\n\n        for (let i = 0; i < orderB.length; i++) {\n            if (!this.contains(cross, orderB[i])) {\n                cross.push(orderB[i]);\n            }\n        }\n\n        for (let i = 0; i < orderA.length; i++) {\n            if (!this.contains(cross, orderA[i])) {\n                cross.push(orderA[i]);\n            }\n        }\n\n        return cross;\n    }\n\n    //check if list contains the element\n    contains(list, element) {\n        for (let i = 0; i < list.length; i++) {\n            if (list[i][0] === element[0] && list[i][1] === element[1]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    sortByFitness() {\n        const population = this.population;\n\n        for (let i = 0; i < population.paths.length - 1; i++) {\n            for (let j = i + 1; j < population.paths.length; j++) {\n                if (population.paths[j].fitness > population.paths[i].fitness) {\n                    let tmpPath = population.paths[i].path;\n                    let tmpFitness = population.paths[i].fitness;\n\n                    population.paths[i].path = population.paths[j].path;\n                    population.paths[i].fitness = population.paths[j].fitness;\n\n                    population.paths[j].path = tmpPath;\n                    population.paths[j].fitness = tmpFitness;\n\n                }\n            }\n        }\n    }\n}","import React from 'react';\nimport './Canvas.css';\nimport drawCircle from './Animations/drawCircle'\nimport clearCanvas from './Animations/clearCanvas'\nimport animatePath from './Animations/animatePath'\nimport random from './Algorithms/random'\nimport swap from './Algorithms/swap'\nimport simulatedAnnealing from './Algorithms/simulatedAnnealing'\nimport GA from './Algorithms/Genetic_Algorithm/GA'\n\n\n//TODO: set animation time to be fixed to some time: calculating how many paths there are in the list.\n//TODO: Save the top 5 paths from previous generation.\n\nclass Canvas extends React.Component {\n    state = {\n        circles : [],\n        bestPath : [],\n        bestDistance : -1,\n        distance : null,\n        drawing: false,\n    }\n\n    /**\n     * \n     * @param {int} x   x coordinate of the circle\n     * @param {int} y   y coordinate of the circle\n     */\n    addCircle(x, y) {\n        let circlesCopy = this.state.circles.slice();\n        circlesCopy.push([x, y]);\n\n        //shuffle list of circle locations\n        swap(circlesCopy);\n\n        this.setState({circles : circlesCopy});\n        drawCircle(this.refs.canvas, x, y);\n    }\n\n    /**\n     * @param {double} currentDistance  distance of the current path\n     * @param {double} bestDistance     distance of the best path\n     */\n    setDistances = (currentDistance, bestDistance) => {\n        this.setState({distance : currentDistance,\n                    bestDistance : bestDistance});\n        \n    }\n    \n    /**\n     * Resets state and clears the canvas\n     */\n    resetState() {\n        if (this.state.drawing === true) {\n            alert('Wait for animation to finish before resetting!');\n            return;\n        }\n\n        clearCanvas(this.refs.canvas);\n        clearCanvas(this.refs.canvas2);\n\n        this.setState({circles : [], \n                    bestDistance : -1,\n                    distance : null,\n                    drawing : false}\n                    );\n    }\n\n    /**\n     * Changes the state of drawing to false for when the animations are finished.\n     */\n    doneDrawing = () => {\n        this.setState({drawing : false});\n    }\n\n    /**\n     * Method that handles which algorithm to use to solve the TSP.\n     * \n     * @param {String} algorithm    Name of the algorithm to be used\n     */\n    selectAlgorithm(algorithm) {\n\n        //check list size\n        if (this.state.circles.length < 2) {\n            alert('Must contain at least 2 or more circles to find paths');\n            return;\n        }\n        else if (this.state.drawing === true) {\n            alert('Wait for animation to finish before selecting another algorithm!');\n            return;\n        }\n\n        clearCanvas(this.refs.canvas2);\n        this.setState({drawing : true});\n\n        //reset distances\n        this.setDistances(null, -1);\n\n        var paths, distances;\n        \n        if (algorithm === \"SA\") {\n            [paths, distances] = simulatedAnnealing(this.state.circles);\n        }\n        else if (algorithm === \"randomSwap\") {\n            [paths, distances] = random(this.state.circles, 50);\n        }\n        else if (algorithm === \"GA\") {\n            let ga = new GA(this.state.circles);\n            [paths, distances] = ga.evole(1000);\n        }\n\n        animatePath(this.refs.canvas, this.refs.canvas2, paths, distances, this.setDistances, this.doneDrawing);\n    }\n\n    /**\n     * Render method\n     */\n    render() {\n        var best;\n\n\n        if (this.state.bestDistance === -1){\n            best = \"\";\n        }\n        else {\n            best = this.state.bestDistance;\n        }\n\n        return (\n            <div className=\"container\">\n                <div>\n                    <canvas ref=\"canvas\" width={1000} height={980}\n                            onClick={(e) => this.addCircle(e.clientX, e.clientY)}\n                    />\n\n                    <div id=\"div2\">\n                        <p>Current Solution Distance</p>\n                        <canvas ref=\"canvas2\" id=\"distancegraph\" width={500} height={500}\n                        />\n                    </div>\n\n                </div>\n\n                <p className=\"scoreboard\">Current Distance: {this.state.distance}</p>\n                <p className=\"scoreboard\">Best Distance: {best}</p>\n\n                <div>\n                    <button className=\"btn\" onClick={() => this.selectAlgorithm('randomSwap')}>Random Swap</button>\n                    <button className=\"btn\" onClick={() => this.selectAlgorithm('SA')}>Simulated Anealing</button>\n                    <button className=\"btn\" onClick={() => this.selectAlgorithm('GA')}>Genetic Algorithm</button>\n                    <button className=\"btn\" onClick={() => this.resetState()}>Reset</button>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default Canvas;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Canvas from './Canvas';\n\nReactDOM.render(<Canvas />, document.getElementById('root'));\n"],"sourceRoot":""}